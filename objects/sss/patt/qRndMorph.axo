<objdefs appVersion="1.0.11">
   <obj.normal id="qRndMorph" uuid="9d63ddd7-e7ac-434d-bf6f-b4700f98d4eb">
      <sDescription>Interpolated wavetable shaper.
Turns a phase (phazor oscillator, positive non-bandlimited saw-wave) into a wave using a morphable wavetable.

&quot;mix&quot; morphs through the available waveforms in the wavetable
&quot;start&quot; is the &quot;base&quot; waveform, where it will start when &quot;mix&quot; is at minimum or maximum.
&quot;step&quot; is the stepsize for selecting from the waveforms while morphing with the &quot;mix&quot;. Last step is always the same as the first step, so you could use a saw to morph through the waveforms continuously in one direction.

&quot;harmonic&quot; multiplies the incoming phase to generate higher harmonic waveforms based on root phase.
&quot;quant&quot; sets the amount of waveforms that the mix will morph through. At 64, it will morph back to the &quot;base&quot; waveform.

This module pairs very VERY well with the other shape modules for lots of tonal control!</sDescription>
      <author>Johannes Taelman</author>
      <license>BSD</license>
      <helpPatch>delay.axh</helpPatch>
      <inlets>
         <frac32 name="mix"/>
         <frac32 name="step"/>
         <bool32 name="rnd"/>
      </inlets>
      <outlets>
         <frac32 name="1"/>
         <frac32 name="2"/>
         <frac32 name="3"/>
         <frac32 name="4"/>
         <frac32 name="5"/>
         <frac32 name="6"/>
         <frac32 name="7"/>
         <frac32 name="8"/>
         <int32 name="div"/>
      </outlets>
      <displays/>
      <params>
         <frac32.u.map name="mix"/>
         <int32 name="quant">
            <MinValue i="1"/>
            <MaxValue i="64"/>
         </int32>
         <int32 name="step">
            <MinValue i="0"/>
            <MaxValue i="64"/>
         </int32>
         <bool32.tgl name="rnd"/>
         <frac32.s.map name="CV"/>
         <int32 name="channel">
            <MinValue i="0"/>
            <MaxValue i="7"/>
         </int32>
         <frac32.s.map name="max1"/>
         <frac32.s.map name="min1"/>
         <frac32.s.map name="max2"/>
         <frac32.s.map name="min2"/>
         <frac32.s.map name="max3"/>
         <frac32.s.map name="min3"/>
         <frac32.s.map name="max4"/>
         <frac32.s.map name="min4"/>
         <frac32.s.map name="max5"/>
         <frac32.s.map name="min5"/>
         <frac32.s.map name="max6"/>
         <frac32.s.map name="min6"/>
         <frac32.s.map name="max7"/>
         <frac32.s.map name="min7"/>
         <frac32.s.map name="max8"/>
         <frac32.s.map name="min8"/>
      </params>
      <attribs>
         <spinner name="presets" MinValue="1" MaxValue="128" DefaultValue="0"/>
      </attribs>
      <code.declaration><![CDATA[static const uint32_t LENGTH = (attr_presets<<3);
int16_t *array;
int rtrig;

int32_t mix;
int32_t tablemix(int32_t WaveA,int32_t WaveB,int32_t Mix){
	mix=___SMMUL(((1<<27)-Mix)<<3,WaveA<<2)+___SMMUL(Mix<<3,WaveB<<2)+(1<<26);
}
int32_t F;
int32_t MX(int32_t T){
	T=T>0?T:-T;
	T=T&((1<<28)-1);
	F=T>(1<<27)?(1<<28)-T:T;
}
int32_t MIX1a;
int32_t MIX1;
int32_t W[2];
int32_t out1;
int32_t out2;
int32_t smooth1;
int32_t M1step;
int32_t M1prv;
int i;
int j;

int32_t prev;]]></code.declaration>
      <code.init><![CDATA[static int16_t _array[LENGTH] __attribute__ ((section (".sdram")));
array = &_array[0];

for(i=0;i<LENGTH;i++){
	array[i]=((int32_t)GenerateRandomNumber())>>16;
}]]></code.init>
      <code.krate><![CDATA[int rnd=param_rnd+inlet_rnd;
if((rnd>0)&&!rtrig){
	rtrig=1;
	for(i=0;i<attr_presets;i++){
	if(!((W[0]==i)||(W[1]==i))){
	for(j=0;j<8;j++){
	array[j+(i<<3)]=((int32_t)GenerateRandomNumber())>>16;}
	}}
}
else if (rnd==0){rtrig=0;}

if(!(prev==param_CV)){
	if(MIX1a>(1<<29)){
		array[param_channel+(W[1]<<3)]=param_CV>>11;
	}
}


int max;
MIX1a=inlet_mix+param_mix;
MIX1a=MIX1a&((1<<27)-1);

int32_t quant1=param_quant+1;
float32_t step=((float32_t)(1<<26))/(quant1)*(inlet_step+param_step);
outlet_div=quant1;

W[0]=((MIX1a>>4)*quant1)>>23;
MIX1a=(MIX1a-(W[0]<<27)/quant1)*quant1;
W[1]=W[0]*step+step;
W[0]=W[0]*step;

for(i=0;i<2;i++){
W[i]=W[i]-(W[i]/attr_presets)*attr_presets;
W[i]=W[i]<0?W[i]+attr_presets:W[i];
}

tablemix(array[(W[0]<<3)]<<11,array[(W[1]<<3)]<<11,MIX1a);
outlet_1=___SMMUL(mix<<3,param_max1-param_min1<<2)+param_min1;
tablemix(array[1+(W[0]<<3)]<<11,array[1+(W[1]<<3)]<<11,MIX1a);
outlet_2=___SMMUL(mix<<3,param_max2-param_min2<<2)+param_min2;
tablemix(array[2+(W[0]<<3)]<<11,array[2+(W[1]<<3)]<<11,MIX1a);
outlet_3=___SMMUL(mix<<3,param_max3-param_min3<<2)+param_min3;
tablemix(array[3+(W[0]<<3)]<<11,array[3+(W[1]<<3)]<<11,MIX1a);
outlet_4=___SMMUL(mix<<3,param_max4-param_min4<<2)+param_min4;
tablemix(array[4+(W[0]<<3)]<<11,array[4+(W[1]<<3)]<<11,MIX1a);
outlet_5=___SMMUL(mix<<3,param_max5-param_min5<<2)+param_min5;
tablemix(array[5+(W[0]<<3)]<<11,array[5+(W[1]<<3)]<<11,MIX1a);
outlet_6=___SMMUL(mix<<3,param_max6-param_min6<<2)+param_min6;
tablemix(array[6+(W[0]<<3)]<<11,array[6+(W[1]<<3)]<<11,MIX1a);
outlet_7=___SMMUL(mix<<3,param_max7-param_min7<<2)+param_min7;
tablemix(array[7+(W[0]<<3)]<<11,array[7+(W[1]<<3)]<<11,MIX1a);
outlet_8=___SMMUL(mix<<3,param_max8-param_min8<<2)+param_min8;

prev=param_CV;]]></code.krate>
   </obj.normal>
</objdefs>